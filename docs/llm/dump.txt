===============================================================================
PROJECT: multiplicationdrill
DATE: Fri Feb 20 10:05:44 AM EST 2026
===============================================================================

-------------------------------------------------------------------------------
FILE: .github/workflows/ci-cd.yml
-------------------------------------------------------------------------------
# ==============================================================================
# CI/CD Pipeline with Playwright Best Practices
# ==============================================================================
# This workflow implements ALL Playwright CI best practices:
#
# 1. BROWSER CACHING
#    - Caches Playwright browsers to speed up subsequent runs
#    - Uses hash of playwright version as cache key
#
# 2. OPTIMIZED BROWSER INSTALLATION
#    - Only installs browsers needed for testing
#    - Uses --with-deps for system dependencies
#
# 3. ARTIFACT UPLOAD
#    - Always uploads HTML report for debugging
#    - Uploads trace files when tests fail
#
# 4. GITHUB REPORTER
#    - Test results appear as PR annotations
#    - Easy to see what failed without leaving GitHub
#
# @see https://playwright.dev/docs/ci
# @see https://playwright.dev/docs/best-practices#run-tests-on-ci
# ==============================================================================

name: CI/CD Pipeline

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  # ============================================================================
  # UNIT TESTS
  # ============================================================================
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x, 22.x, 24.x]
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Run linter
        run: yarn lint

      - name: Run type check
        run: yarn type-check

      - name: Run unit tests with coverage
        run: yarn test:coverage:ci

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        if: matrix.node-version == '22.x'
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  # ============================================================================
  # E2E TESTS WITH PLAYWRIGHT
  # ============================================================================
  # This job implements ALL Playwright CI best practices
  # ============================================================================
  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      # ========================================================================
      # PLAYWRIGHT BROWSER CACHING
      # ========================================================================
      # WHY: Playwright browsers are ~500MB each
      # Caching them saves significant download time on each run
      # 
      # Cache key includes:
      # - OS (ubuntu-latest)
      # - Playwright version from package.json
      #
      # This ensures cache is invalidated when Playwright version changes
      # ========================================================================
      - name: Get Playwright version
        id: playwright-version
        run: echo "version=$(yarn info @playwright/test version --json | jq -r '.data')" >> $GITHUB_OUTPUT

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ steps.playwright-version.outputs.version }}

      # ========================================================================
      # OPTIMIZED BROWSER INSTALLATION
      # ========================================================================
      # BEST PRACTICE: Only install browsers you actually use
      #
      # Options:
      # - 'npx playwright install --with-deps' - installs ALL browsers
      # - 'npx playwright install chromium --with-deps' - installs only Chromium
      #
      # We install all browsers because our config tests on chromium, firefox,
      # and webkit. If you only need Chromium, change this to save time.
      #
      # --with-deps installs system dependencies (fonts, libraries, etc.)
      # This is REQUIRED on fresh CI machines
      # ========================================================================
      - name: Install Playwright Browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps

      # Install only system deps if browsers were cached
      - name: Install Playwright system dependencies
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps

      # ========================================================================
      # BUILD PROJECT
      # ========================================================================
      # E2E tests run against the built application
      # This ensures we're testing what will actually be deployed
      # ========================================================================
      - name: Build project for E2E tests
        run: yarn build

      # ========================================================================
      # RUN E2E TESTS
      # ========================================================================
      # The playwright.config.ts handles:
      # - Starting the dev server
      # - Running tests in parallel
      # - Collecting traces on failure
      # - Generating HTML report
      # ========================================================================
      - name: Run E2E tests
        run: yarn test:e2e

      # ========================================================================
      # ARTIFACT UPLOAD - ALWAYS
      # ========================================================================
      # Upload the HTML report even if tests pass
      # This allows reviewing test results in detail
      #
      # if: always() ensures upload happens even when tests fail
      # ========================================================================
      - name: Upload Playwright Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      # ========================================================================
      # ARTIFACT UPLOAD - TEST RESULTS (on failure)
      # ========================================================================
      # Test results directory contains:
      # - Screenshots
      # - Videos (if recorded)
      # - Traces
      #
      # Only uploaded on failure to save storage
      # ========================================================================
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-results
          path: test-results/
          retention-days: 7

  # ============================================================================
  # BUILD AND DEPLOY
  # ============================================================================
  build:
    needs: [test, e2e-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Build project
        run: yarn build

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./dist

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'

    permissions:
      pages: write
      id-token: write

    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


-------------------------------------------------------------------------------
FILE: .github/workflows/coverage-comment.yml
-------------------------------------------------------------------------------
name: Coverage Comment

on:
  pull_request:

jobs:
  coverage:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      pull-requests: write
    
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'
        cache: 'yarn'

    - name: Install dependencies
      run: yarn install --frozen-lockfile

    - name: Run tests with coverage
      run: yarn test:coverage

    - name: Coverage Summary
      uses: irongut/CodeCoverageSummary@v1.3.0
      with:
        filename: coverage/lcov.info
        badge: true
        format: markdown
        output: both

    - name: Add Coverage PR Comment
      uses: marocchino/sticky-pull-request-comment@v2
      if: github.event_name == 'pull_request'
      with:
        recreate: true
        path: code-coverage-results.md

    - name: Write to Job Summary
      run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY

-------------------------------------------------------------------------------
FILE: Dockerfile.e2e
-------------------------------------------------------------------------------
FROM mcr.microsoft.com/playwright:v1.58.2-noble

WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile
COPY . .
RUN yarn build


-------------------------------------------------------------------------------
FILE: e2e/pages/index.ts
-------------------------------------------------------------------------------
/**
 * Page Object Model Exports
 * 
 * This file exports all page objects for easy importing in tests.
 * 
 * Usage in tests:
 *   import { QuizPage } from './pages';
 */

export { QuizPage } from './quiz-page';


-------------------------------------------------------------------------------
FILE: e2e/pages/quiz-page.ts
-------------------------------------------------------------------------------
/**
 * QuizPage - Page Object Model for the Multiplication Drill application
 * 
 * FIXES APPLIED:
 * 1. Changed slider locators to use ID selectors (getByLabel doesn't work reliably
 *    when there's both a <label> and aria-label with different text)
 * 2. Changed slider interaction from fill() to proper range input handling
 * 3. Fixed theme toggle button locator (emoji matching is unreliable)
 */

import { type Page, type Locator, expect } from '@playwright/test';

type DifficultyLevel = 1 | 2 | 3 | 4;

interface DifficultyConfig {
  name: string;
  min: number;
  max: number;
}

const DIFFICULTY_MAP: Record<DifficultyLevel, DifficultyConfig> = {
  1: { name: 'Easy', min: 2, max: 5 },
  2: { name: 'Medium', min: 4, max: 8 },
  3: { name: 'Hard', min: 6, max: 12 },
  4: { name: 'Expert', min: 10, max: 20 },
};

export class QuizPage {
  readonly page: Page;

  // Display elements
  readonly display: Locator;
  readonly progressBar: Locator;
  readonly timerDisplay: Locator;

  // Quiz control buttons
  readonly startQuizButton: Locator;
  readonly stopQuizButton: Locator;

  // Manual mode buttons
  readonly incrementButton: Locator;
  readonly resetButton: Locator;

  // Settings sliders - USE ID LOCATORS instead of getByLabel
  // getByLabel fails when <label> text differs from aria-label
  readonly questionTimeSlider: Locator;
  readonly answerTimeSlider: Locator;
  readonly difficultySlider: Locator;

  // Settings value displays
  readonly questionTimeValue: Locator;
  readonly answerTimeValue: Locator;
  readonly difficultyValue: Locator;

  // Auto-update checkbox
  readonly autoUpdateCheckbox: Locator;

  // Theme toggle
  readonly themeToggle: Locator;

  // Status indicators
  readonly modeStatus: Locator;
  readonly quizStatus: Locator;

  constructor(page: Page) {
    this.page = page;

    // Display elements - ID locators are acceptable fallback
    this.display = page.locator('#display');
    this.progressBar = page.locator('#progressBar');
    this.timerDisplay = page.locator('#timerDisplay');

    // Quiz control buttons - getByRole with name is most resilient
    this.startQuizButton = page.getByRole('button', { name: 'Start Quiz' });
    this.stopQuizButton = page.getByRole('button', { name: 'Stop Quiz' });

    // Manual mode buttons
    this.incrementButton = page.getByRole('button', { name: 'Increment' });
    this.resetButton = page.getByRole('button', { name: 'Reset' });

    // FIX: Use ID locators for sliders instead of getByLabel
    // The HTML has <label for="questionTime">Question Time:</label> AND
    // <input aria-label="Question time in seconds"> which can cause conflicts
    this.questionTimeSlider = page.locator('#questionTime');
    this.answerTimeSlider = page.locator('#answerTime');
    this.difficultySlider = page.locator('#difficulty');

    // Settings value displays
    this.questionTimeValue = page.locator('#questionTimeValue');
    this.answerTimeValue = page.locator('#answerTimeValue');
    this.difficultyValue = page.locator('#difficultyValue');

    // FIX: Use locator with type=checkbox and label association
    this.autoUpdateCheckbox = page.locator('#autoUpdate');

    // FIX: Theme toggle - use class selector since there's no ID in HTML
    // and emoji matching with getByRole is unreliable
    this.themeToggle = page.locator('.theme-toggle');

    // Status indicators
    this.modeStatus = page.locator('#modeStatus');
    this.quizStatus = page.locator('#quizStatus');
  }

  // Navigation
  async goto(): Promise<void> {
    await this.page.goto('/');
    await expect(this.display).toBeVisible();
  }

  // Quiz control methods
  async startQuiz(): Promise<void> {
    await this.startQuizButton.click();
    await expect(this.stopQuizButton).toBeVisible();
  }

  async stopQuiz(): Promise<void> {
    await this.stopQuizButton.click();
    await expect(this.startQuizButton).toBeVisible();
  }

  async isQuizRunning(): Promise<boolean> {
    return this.stopQuizButton.isVisible();
  }

  // Manual mode methods
  async increment(): Promise<void> {
    await this.incrementButton.click();
  }

  async reset(): Promise<void> {
    await this.resetButton.click();
  }

  async setAutoUpdate(enable: boolean): Promise<void> {
    if (enable) {
      await this.autoUpdateCheckbox.check();
    } else {
      await this.autoUpdateCheckbox.uncheck();
    }
  }

  // FIX: Proper slider interaction - fill() doesn't work on range inputs!
  // Use evaluate() to set the value directly and dispatch input event
  async setQuestionTime(seconds: number): Promise<void> {
    await this.questionTimeSlider.evaluate((el: HTMLInputElement, val: number) => {
      el.value = val.toString();
      el.dispatchEvent(new Event('input', { bubbles: true }));
    }, seconds);
    await expect(this.questionTimeValue).toHaveText(`${seconds}s`);
  }

  async setAnswerTime(seconds: number): Promise<void> {
    await this.answerTimeSlider.evaluate((el: HTMLInputElement, val: number) => {
      el.value = val.toString();
      el.dispatchEvent(new Event('input', { bubbles: true }));
    }, seconds);
    await expect(this.answerTimeValue).toHaveText(`${seconds}s`);
  }

  async setDifficulty(level: DifficultyLevel): Promise<void> {
    await this.difficultySlider.evaluate((el: HTMLInputElement, val: number) => {
      el.value = val.toString();
      el.dispatchEvent(new Event('input', { bubbles: true }));
    }, level);
    const expectedName = DIFFICULTY_MAP[level].name;
    await expect(this.difficultyValue).toHaveText(expectedName);
  }

  // Toggle theme
  async toggleTheme(): Promise<void> {
    await this.themeToggle.click();
  }

  // Helper methods
  getDifficultyRange(level: DifficultyLevel): { min: number; max: number } {
    return DIFFICULTY_MAP[level];
  }

  async getMultiplier(): Promise<number | null> {
    const text = await this.display.textContent();
    if (!text) return null;
    // Match pattern like "5 Ã— 10 = 50" and extract the second number (multiplier)
    const match = text.match(/\d+\s*Ã—\s*(\d+)/);
    return match ? parseInt(match[1], 10) : null;
  }

  // Assertion helpers
  async expectDisplayToShow(counter: number, multiplier: number): Promise<void> {
    const expected = `${counter} Ã— ${multiplier} = ${counter * multiplier}`;
    await expect(this.display).toHaveText(expected);
  }

  async expectQuizQuestion(): Promise<void> {
    await expect(this.display).toHaveText(/^\d+\s*Ã—\s*\d+$/);
  }

  async expectQuizAnswer(): Promise<void> {
    await expect(this.display).toHaveText(/^\d+\s*Ã—\s*\d+\s*=\s*\d+$/);
  }

  async expectControlsDisabled(disabled: boolean): Promise<void> {
    if (disabled) {
      await expect(this.incrementButton).toBeDisabled();
      await expect(this.resetButton).toBeDisabled();
      await expect(this.questionTimeSlider).toBeDisabled();
      await expect(this.answerTimeSlider).toBeDisabled();
      await expect(this.difficultySlider).toBeDisabled();
      await expect(this.autoUpdateCheckbox).toBeDisabled();
    } else {
      await expect(this.incrementButton).toBeEnabled();
      await expect(this.resetButton).toBeEnabled();
      await expect(this.questionTimeSlider).toBeEnabled();
      await expect(this.answerTimeSlider).toBeEnabled();
      await expect(this.difficultySlider).toBeEnabled();
      await expect(this.autoUpdateCheckbox).toBeEnabled();
    }
  }

  async expectStatus(mode: 'Manual' | 'Quiz', quizState: 'Stopped' | 'Running'): Promise<void> {
    await expect(this.modeStatus).toHaveText(mode);
    await expect(this.quizStatus).toHaveText(quizState);
  }

  async expectMultiplierInRange(level: DifficultyLevel): Promise<void> {
    const multiplier = await this.getMultiplier();
    const range = this.getDifficultyRange(level);
    
    expect(multiplier).not.toBeNull();
    expect(multiplier).toBeGreaterThanOrEqual(range.min);
    expect(multiplier).toBeLessThanOrEqual(range.max);
  }
}


-------------------------------------------------------------------------------
FILE: e2e/quiz.spec.ts
-------------------------------------------------------------------------------
/**
 * Multiplication Drill E2E Tests
 * 
 * FIXES APPLIED:
 * 1. Use Unicode escape for multiplication sign to avoid encoding issues
 * 2. Fixed regex patterns to match actual app output
 * 3. Increased timeouts for quiz transitions
 */

import { test, expect } from '@playwright/test';
import { QuizPage } from './pages/quiz-page';

// Unicode multiplication sign (Ã—) - using escape to avoid encoding issues
const TIMES = '\u00D7';

let quizPage: QuizPage;

test.describe('Multiplication Drill Application', () => {
  test.beforeEach(async ({ page }) => {
    quizPage = new QuizPage(page);
    await quizPage.goto();
  });

  // ===========================================================================
  // INITIAL STATE TESTS
  // ===========================================================================

  test.describe('Initial State', () => {
    test('should load the page with correct title', async ({ page }) => {
      await expect(page).toHaveTitle('Reactive Math Quiz');
    });

    test('should display initial manual mode equation', async () => {
      // Should show pattern like "0 Ã— 7 = 0" (counter Ã— multiplier = result)
      const pattern = new RegExp(`^\\d+\\s*${TIMES}\\s*\\d+\\s*=\\s*\\d+$`);
      await expect(quizPage.display).toHaveText(pattern);
    });

    test('should have all controls enabled in manual mode', async () => {
      await quizPage.expectControlsDisabled(false);
    });

    test('should show correct initial status', async () => {
      await quizPage.expectStatus('Manual', 'Stopped');
    });
  });

  // ===========================================================================
  // MANUAL MODE TESTS
  // ===========================================================================

  test.describe('Manual Mode', () => {
    test('should increment counter when clicking increment button', async () => {
      const multiplier = await quizPage.getMultiplier();
      expect(multiplier).not.toBeNull();

      await quizPage.increment();
      await quizPage.expectDisplayToShow(1, multiplier!);

      await quizPage.increment();
      await quizPage.expectDisplayToShow(2, multiplier!);
    });

    test('should reset counter and generate new multiplier when clicking reset', async () => {
      await quizPage.increment();
      await quizPage.increment();

      await quizPage.reset();

      // Verify counter is 0 - the display should show "0 Ã— X = 0"
      const pattern = new RegExp(`^0\\s*${TIMES}\\s*\\d+\\s*=\\s*0$`);
      await expect(quizPage.display).toHaveText(pattern);
    });

    test('should verify multiplication calculations are correct', async () => {
      const multiplier = await quizPage.getMultiplier();
      expect(multiplier).not.toBeNull();

      for (let i = 1; i <= 5; i++) {
        await quizPage.increment();
        await quizPage.expectDisplayToShow(i, multiplier!);
      }
    });
  });

  // ===========================================================================
  // QUIZ MODE TESTS
  // ===========================================================================

  test.describe('Quiz Mode', () => {
    test('should start quiz when clicking Start Quiz button', async () => {
      await quizPage.startQuiz();
      await quizPage.expectStatus('Quiz', 'Running');
    });

    test('should disable manual controls during quiz', async () => {
      await quizPage.startQuiz();
      await quizPage.expectControlsDisabled(true);
      await quizPage.stopQuiz();
      await quizPage.expectControlsDisabled(false);
    });

    test('should update status panel during quiz', async () => {
      await quizPage.expectStatus('Manual', 'Stopped');
      await quizPage.startQuiz();
      await quizPage.expectStatus('Quiz', 'Running');
      await quizPage.stopQuiz();
      await quizPage.expectStatus('Manual', 'Stopped');
    });

    test('should transition from question to answer phase', async () => {
      await quizPage.startQuiz();

      // Wait for the answer phase - the display will include "="
      // Using Unicode escape for multiplication sign
      const answerPattern = new RegExp(`^\\d+\\s*${TIMES}\\s*\\d+\\s*=\\s*\\d+$`);
      await expect(quizPage.display).toHaveText(answerPattern, {
        timeout: 10000, // Allow more time for question phase to complete
      });

      await quizPage.stopQuiz();
    });

    test('should generate new problems', async () => {
      await quizPage.startQuiz();

      const firstProblem = await quizPage.display.textContent();

      // Wait for content to change (new question or answer phase)
      await expect(async () => {
        const currentProblem = await quizPage.display.textContent();
        expect(currentProblem).not.toBe(firstProblem);
      }).toPass({
        timeout: 10000, // Increased timeout
      });

      await quizPage.stopQuiz();
    });
  });

  // ===========================================================================
  // SETTINGS TESTS
  // ===========================================================================

  test.describe('Settings', () => {
    test('should change difficulty and update multiplier range', async () => {
      // Set to Easy (level 1) - range 2-5
      await quizPage.setDifficulty(1);
      await expect(quizPage.difficultyValue).toHaveText('Easy');
      
      // Reset to get new multiplier in the correct range
      await quizPage.reset();
      await quizPage.expectMultiplierInRange(1);
    });

    test('should adjust question time slider', async () => {
      await quizPage.setQuestionTime(10);
      await expect(quizPage.questionTimeValue).toHaveText('10s');
    });

    test('should adjust answer time slider', async () => {
      await quizPage.setAnswerTime(5);
      await expect(quizPage.answerTimeValue).toHaveText('5s');
    });

    test('should have proper ARIA attributes on sliders', async () => {
      await expect(quizPage.difficultySlider).toHaveAttribute('aria-valuemin', '1');
      await expect(quizPage.difficultySlider).toHaveAttribute('aria-valuemax', '4');
    });
  });

  // ===========================================================================
  // THEME TOGGLE TESTS
  // ===========================================================================

  test.describe('Theme Toggle', () => {
    test('should start in dark mode', async ({ page }) => {
      await expect(page.locator('body')).not.toHaveClass(/light-mode/);
    });

    test('should toggle to light mode', async ({ page }) => {
      await quizPage.toggleTheme();
      await expect(page.locator('body')).toHaveClass(/light-mode/);
    });

    test('should toggle back to dark mode', async ({ page }) => {
      await quizPage.toggleTheme();
      await expect(page.locator('body')).toHaveClass(/light-mode/);
      await quizPage.toggleTheme();
      await expect(page.locator('body')).not.toHaveClass(/light-mode/);
    });
  });
});

// =============================================================================
// MOBILE VIEWPORT TESTS
// =============================================================================

test.describe('Mobile Viewport', () => {
  test.use({ viewport: { width: 375, height: 667 } });

  test('should display correctly on mobile viewport', async ({ page }) => {
    const quizPage = new QuizPage(page);
    await quizPage.goto();

    await expect(quizPage.display).toBeVisible();
    await expect(quizPage.startQuizButton).toBeVisible();
    await expect(quizPage.incrementButton).toBeVisible();

    // Verify no horizontal scrolling
    const bodyWidth = await page.locator('body').evaluate(el => el.scrollWidth);
    const viewportWidth = await page.locator('body').evaluate(el => el.clientWidth);
    expect(bodyWidth).toBeLessThanOrEqual(viewportWidth);
  });
});


-------------------------------------------------------------------------------
FILE: index.html
-------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactive Math Quiz</title>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">ðŸŒ“</button>
    <div class="container">
        <h1>Reactive Math Quiz</h1>
        
        <div class="section">
            <div class="quiz-display" id="display">Press Start Quiz</div>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="timer-display" id="timerDisplay">Ready</div>
        </div>

        <div class="section">
            <h3 style="margin-bottom: 15px;">Quiz Settings</h3>
            <div class="controls">
                <div class="slider-group">
                    <label for="questionTime">Question Time:</label>
                    <input type="range" id="questionTime" min="1" max="30" value="5" 
                           aria-label="Question time in seconds"
                           aria-valuemin="1" aria-valuemax="30" aria-valuenow="5">
                    <span class="slider-value" id="questionTimeValue">5s</span>
                </div>
                <div class="slider-group">
                    <label for="answerTime">Answer Time:</label>
                    <input type="range" id="answerTime" min="1" max="30" value="3"
                           aria-label="Answer time in seconds"
                           aria-valuemin="1" aria-valuemax="30" aria-valuenow="3">
                    <span class="slider-value" id="answerTimeValue">3s</span>
                </div>
                <div class="slider-group">
                    <label for="difficulty">Difficulty:</label>
                    <input type="range" id="difficulty" min="1" max="4" step="1" value="3"
                           aria-label="Difficulty level"
                           aria-valuemin="1" aria-valuemax="4" aria-valuenow="3"
                           aria-valuetext="Hard">
                    <span class="slider-value" id="difficultyValue">Hard</span>
                </div>
                <button id="quizButton" onclick="toggleQuiz()">Start Quiz</button>
            </div>
        </div>

        <div class="section">
            <h3 style="margin-bottom: 15px;">Manual Mode</h3>
            <div class="button-group">
                <button id="incrementBtn" onclick="increment()">Increment</button>
                <button id="resetBtn" onclick="reset()">Reset</button>
            </div>
            <div class="toggle" style="margin-top: 15px;">
                <input type="checkbox" id="autoUpdate" onchange="toggleAutoUpdate(this.checked)">
                <label for="autoUpdate">Auto-update (3s intervals)</label>
            </div>
        </div>

        <div class="status">
            <div class="status-item">
                <span>Mode:</span>
                <span class="status-value" id="modeStatus">Manual</span>
            </div>
            <div class="status-item">
                <span>Quiz State:</span>
                <span class="status-value" id="quizStatus">Stopped</span>
            </div>
            <div class="status-item">
                <span>Last Update:</span>
                <span class="status-value" id="updateTime">Never</span>
            </div>
        </div>
    </div>

    <script type="module" src="/src/main.ts"></script>
</body>
</html>

-------------------------------------------------------------------------------
FILE: package.json
-------------------------------------------------------------------------------
{
  "name": "multiplicationdrill",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "lint": "eslint src --max-warnings 0",
    "type-check": "tsc --noEmit",
    "dev": "vite",
    "build": "tsc && vite build",
    "test": "vitest",
    "test:run": "vitest run",
    "test:e2e": "playwright test",
    "test:coverage:ci": "vitest run --coverage",
    "e2e:container:build": "podman build -f Dockerfile.e2e -t multiplicationdrill-e2e .",
    "e2e:container": "podman run --rm -e CI=true -v $(pwd)/playwright-report:/app/playwright-report:Z -v $(pwd)/test-results:/app/test-results:Z multiplicationdrill-e2e yarn test:e2e",
    "e2e:containernoci": "podman run --rm -it --cpus=8 --memory=8g -v $(pwd)/playwright-report:/app/playwright-report:Z -v $(pwd)/test-results:/app/test-results:Z multiplicationdrill-e2e yarn test:e2e",
    "test:all": "yarn lint && yarn type-check && yarn test:run && yarn e2e:container:build && yarn e2e:containernoci"
  },
  "devDependencies": {
    "@eslint/js": "^10.0.0",
    "@playwright/test": "^1.58.2",
    "@types/node": "^25.3.0",
    "@vitest/coverage-v8": "^4.0.18",
    "@vitest/ui": "^4.0.18",
    "eslint": "^10.0.0",
    "globals": "^17.0.0",
    "jsdom": "^28.1.0",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.56.0",
    "vite": "^7.3.1",
    "vitest": "^4.0.18"
  }
}


-------------------------------------------------------------------------------
FILE: playwright.config.ts
-------------------------------------------------------------------------------
/**
 * Playwright Configuration
 * 
 * This configuration follows ALL Playwright best practices:
 * 
 * 1. TRACE ON FIRST RETRY: Captures detailed trace only when a test fails
 *    and is being retried. This saves resources while providing debugging info.
 *    
 * 2. SCREENSHOTS ON FAILURE: Captures screenshot when test fails to help
 *    identify visual issues.
 *    
 * 3. VIDEO ON FIRST RETRY: Records video only when retrying failed tests.
 *    Useful for debugging but not for every test run.
 *    
 * 4. PROPER TIMEOUTS: Balanced between fast feedback and stability.
 *    
 * 5. CROSS-BROWSER TESTING: Runs on Chromium, Firefox, and WebKit.
 *    
 * 6. CI OPTIMIZATIONS: Different settings for CI vs local development.
 *
 * @see https://playwright.dev/docs/test-configuration
 * @see https://playwright.dev/docs/best-practices
 */

import { defineConfig, devices } from '@playwright/test';

/**
 * Detect if running in CI environment
 * GitHub Actions sets CI=true automatically
 */
const isCI = !!process.env.CI;

export default defineConfig({
  // ===========================================================================
  // TEST DIRECTORY AND FILE PATTERNS
  // ===========================================================================
  
  /**
   * Directory containing test files
   */
  testDir: './e2e',

  /**
   * Pattern to match test files
   * Using .spec.ts extension is conventional for Playwright
   */
  testMatch: '**/*.spec.ts',

  // ===========================================================================
  // PARALLELIZATION SETTINGS
  // ===========================================================================

  /**
   * Run tests in files in parallel
   * Each test file runs in its own worker for isolation
   */
  fullyParallel: true,

  /**
   * Fail the build on CI if test.only() is left in source code
   * This prevents accidentally skipping tests in CI
   */
  forbidOnly: isCI,

  // ===========================================================================
  // RETRY CONFIGURATION
  // ===========================================================================

  /**
   * Retry failed tests
   * - CI: Retry twice to handle flaky infrastructure
   * - Local: No retries for faster feedback during development
   * 
   * WHY 2 retries in CI:
   * - First retry captures trace for debugging
   * - Second retry confirms if it's truly flaky
   */
  retries: isCI ? 2 : 0,

  // ===========================================================================
  // WORKER CONFIGURATION
  // ===========================================================================

  /**
   * Number of parallel workers
   * - CI: Use 1 worker for consistent, reproducible builds
   * - Local: Use default (based on CPU cores) for speed
   * 
   * WHY 1 worker in CI:
   * - More predictable resource usage
   * - Easier to debug failures
   * - GitHub Actions runners have limited parallelism
   */
  workers: isCI ? 1 : undefined,

  // ===========================================================================
  // REPORTER CONFIGURATION
  // ===========================================================================

  /**
   * Reporter configuration
   * - HTML: Creates interactive report viewable in browser
   * - List: Shows test progress in console (good for CI)
   * - GitHub: Annotates PRs with test results (CI only)
   */
  reporter: isCI
    ? [
        ['list'],
        ['html', { open: 'never' }],
        ['github'],
      ]
    : [
        ['html', { open: 'never' }],
      ],

  // ===========================================================================
  // GLOBAL SETTINGS (applied to all projects)
  // ===========================================================================

  use: {
    /**
     * Base URL for navigation
     * All page.goto('/path') calls are relative to this
     */
    baseURL: 'http://localhost:5173',

    // =========================================================================
    // TRACE CONFIGURATION
    // =========================================================================

    /**
     * Collect trace on first retry of failed test
     * 
     * WHY 'on-first-retry':
     * - Traces are expensive to collect and store
     * - Only need them for debugging failures
     * - First retry is when we need the most info
     * 
     * Trace includes:
     * - Timeline of actions
     * - DOM snapshots
     * - Network requests
     * - Console logs
     */
    trace: 'on-first-retry',

    // =========================================================================
    // SCREENSHOT CONFIGURATION
    // =========================================================================

    /**
     * Capture screenshot only when test fails
     * 
     * WHY 'only-on-failure':
     * - Saves storage space
     * - Faster test execution
     * - Still provides debugging info when needed
     */
    screenshot: 'only-on-failure',

    // =========================================================================
    // VIDEO CONFIGURATION
    // =========================================================================

    /**
     * Record video on first retry of failed test
     * 
     * WHY 'on-first-retry':
     * - Videos are large files
     * - Only useful for debugging failures
     * - Provides visual record of what went wrong
     */
    video: 'on-first-retry',

    // =========================================================================
    // TIMEOUT CONFIGURATION
    // =========================================================================

    /**
     * Timeout for each action (click, fill, etc.)
     * Default is 30s, but we reduce it for faster failure detection
     */
    actionTimeout: 10_000,

    /**
     * Timeout for navigation
     */
    navigationTimeout: 30_000,
  },

  // ===========================================================================
  // EXPECT CONFIGURATION
  // ===========================================================================

  expect: {
    /**
     * Timeout for expect() assertions
     * 
     * WHY 5 seconds:
     * - Enough time for animations to complete
     * - Enough for network responses
     * - But fast enough to catch actual failures
     */
    timeout: 5_000,
  },

  // ===========================================================================
  // GLOBAL TIMEOUT
  // ===========================================================================

  /**
   * Maximum time for the entire test (including hooks)
   * 
   * WHY 30 seconds:
   * - Most tests should complete in under 10s
   * - Extra buffer for slow CI environments
   * - Prevents tests from hanging indefinitely
   */
  timeout: 30_000,

  // ===========================================================================
  // PROJECT CONFIGURATION (Multi-browser testing)
  // ===========================================================================

  /**
   * Configure projects for cross-browser testing
   * 
   * WHY test on multiple browsers:
   * - Ensures app works for all users
   * - Catches browser-specific bugs early
   * - Part of Playwright best practices
   */
  projects: [
    {
      name: 'chromium',
      use: {
        ...devices['Desktop Chrome'],
      },
    },
    {
      name: 'firefox',
      use: {
        ...devices['Desktop Firefox'],
      },
    },
    {
      name: 'webkit',
      use: {
        ...devices['Desktop Safari'],
      },
    },
  ],

  // ===========================================================================
  // WEB SERVER CONFIGURATION
  // ===========================================================================

  /**
   * Start the dev server before running tests
   * 
   * WHY configure webServer:
   * - Ensures app is running before tests start
   * - Automatically starts/stops server
   * - Reuses existing server when running locally
   */
  webServer: {
    /**
     * Command to start the development server
     */
    command: 'yarn dev',

    /**
     * Port the server runs on
     */
    port: 5173,

    /**
     * Reuse existing server if already running
     * 
     * WHY true locally:
     * - Faster test starts during development
     * - Can run tests against manually started server
     * 
     * WHY false in CI:
     * - Ensures clean server state
     * - No stale server from previous runs
     */
    reuseExistingServer: !isCI,

    /**
     * Timeout for server to start
     */
    timeout: 120_000,
  },
});


-------------------------------------------------------------------------------
FILE: src/__tests__/signals.test.ts
-------------------------------------------------------------------------------
import { describe, it, expect, vi } from 'vitest';
import { Signal, ComputedSignal, effect } from '../signals';

describe('Signal', () => {
  it('should store and retrieve values', () => {
    const signal = new Signal(5);
    expect(signal.get()).toBe(5);
    
    signal.set(10);
    expect(signal.get()).toBe(10);
  });

  it('should notify observers when value changes', () => {
    const signal = new Signal(5);
    const observer = vi.fn();
    
    // Register observer via effect
    effect(() => {
      signal.get();
      observer();
    });
    
    // Initial call during effect setup
    expect(observer).toHaveBeenCalledTimes(1);
    
    // Change value
    signal.set(10);
    expect(observer).toHaveBeenCalledTimes(2);
  });

  it('should not notify if value does not change', () => {
    const signal = new Signal(5);
    const observer = vi.fn();
    
    effect(() => {
      signal.get();
      observer();
    });
    
    expect(observer).toHaveBeenCalledTimes(1);
    
    // Set same value
    signal.set(5);
    expect(observer).toHaveBeenCalledTimes(1);
  });
});

describe('ComputedSignal', () => {
  it('should compute value based on dependencies', () => {
    const a = new Signal(5);
    const b = new Signal(10);
    const sum = new ComputedSignal(() => a.get() + b.get());
    
    expect(sum.get()).toBe(15);
    
    a.set(7);
    expect(sum.get()).toBe(17);
    
    b.set(20);
    expect(sum.get()).toBe(27);
  });

  it('should only recompute when accessed after becoming stale', () => {
    const signal = new Signal(5);
    const computeFn = vi.fn(() => signal.get() * 2);
    const computed = new ComputedSignal(computeFn);
    
    // First access computes
    expect(computed.get()).toBe(10);
    expect(computeFn).toHaveBeenCalledTimes(1);
    
    // Second access without change doesn't recompute
    expect(computed.get()).toBe(10);
    expect(computeFn).toHaveBeenCalledTimes(1);
    
    // Change dependency
    signal.set(7);
    
    // Access after change recomputes
    expect(computed.get()).toBe(14);
    expect(computeFn).toHaveBeenCalledTimes(2);
  });

  it('should handle nested computed signals', () => {
    const base = new Signal(2);
    const doubled = new ComputedSignal(() => base.get() * 2);
    const quadrupled = new ComputedSignal(() => doubled.get() * 2);
    
    expect(quadrupled.get()).toBe(8);
    
    base.set(3);
    expect(quadrupled.get()).toBe(12);
  });
});

describe('effect', () => {
  it('should run immediately and on dependency changes', () => {
    const signal = new Signal(5);
    const sideEffect = vi.fn();
    
    effect(() => {
      signal.get();
      sideEffect();
    });
    
    expect(sideEffect).toHaveBeenCalledTimes(1);
    
    signal.set(10);
    expect(sideEffect).toHaveBeenCalledTimes(2);
  });

  it('should handle multiple dependencies', () => {
    const a = new Signal(1);
    const b = new Signal(2);
    const sideEffect = vi.fn();
    
    effect(() => {
      a.get();
      b.get();
      sideEffect();
    });
    
    expect(sideEffect).toHaveBeenCalledTimes(1);
    
    a.set(10);
    expect(sideEffect).toHaveBeenCalledTimes(2);
    
    b.set(20);
    expect(sideEffect).toHaveBeenCalledTimes(3);
  });

  it('should support nested effects', () => {
    const signal = new Signal(1);
    const outer = vi.fn();
    const inner = vi.fn();
    
    effect(() => {
      outer();
      signal.get();
      
      effect(() => {
        inner();
        signal.get();
      });
    });
    
    expect(outer).toHaveBeenCalledTimes(1);
    expect(inner).toHaveBeenCalledTimes(1);
    
    signal.set(2);
    // Outer effect runs, creating new inner effect
    expect(outer).toHaveBeenCalledTimes(2);
    // Inner effect runs twice: once from outer re-run, once from signal change
    expect(inner.mock.calls.length).toBeGreaterThanOrEqual(2);
  });
});

-------------------------------------------------------------------------------
FILE: src/__tests__/state.test.ts
-------------------------------------------------------------------------------
import { describe, it, expect, beforeEach } from 'vitest';
import { state, displayText, progressPercent, timerDisplayText } from '../state';

describe('State', () => {
  beforeEach(() => {
    // Reset state to defaults
    state.counter.set(0);
    state.isQuizActive.set(false);
    state.currentPhase.set('idle');
    state.timeRemaining.set(0);
    state.currentProblem.set({ a: 0, b: 0 });
    state.questionTime.set(5);
    state.answerTime.set(3);
  });

  describe('displayText computed signal', () => {
    it('should show manual mode display when quiz is inactive', () => {
      state.counter.set(5);
      state.seed.set(10);
      expect(displayText.get()).toBe('5 Ã— 10 = 50');
      
      state.seed.set(7);
      expect(displayText.get()).toBe('5 Ã— 7 = 35');
    });

    it('should show question during quiz question phase', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('question');
      state.currentProblem.set({ a: 7, b: 8 });
      expect(displayText.get()).toBe('7 Ã— 8');
    });

    it('should show answer during quiz answer phase', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('answer');
      state.currentProblem.set({ a: 7, b: 8 });
      expect(displayText.get()).toBe('7 Ã— 8 = 56');
    });
  });

  describe('progressPercent computed signal', () => {
    it('should return 0 when quiz is inactive', () => {
      state.isQuizActive.set(false);
      expect(progressPercent.get()).toBe(0);
    });

    it('should calculate progress for question phase', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('question');
      state.questionTime.set(10);
      state.timeRemaining.set(7); // 3 seconds elapsed
      expect(progressPercent.get()).toBe(30); // (10-7)/10 * 100
    });

    it('should calculate progress for answer phase', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('answer');
      state.answerTime.set(5);
      state.timeRemaining.set(2); // 3 seconds elapsed
      expect(progressPercent.get()).toBe(60); // (5-2)/5 * 100
    });

    it('should handle zero total time', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('question');
      state.questionTime.set(0);
      expect(progressPercent.get()).toBe(0);
    });
  });

  describe('timerDisplayText computed signal', () => {
    it('should show "Ready" when quiz is inactive', () => {
      state.isQuizActive.set(false);
      expect(timerDisplayText.get()).toBe('Ready');
    });

    it('should show phase and time during quiz', () => {
      state.isQuizActive.set(true);
      state.currentPhase.set('question');
      state.timeRemaining.set(3.5);
      expect(timerDisplayText.get()).toBe('Question: 3.5s');

      state.currentPhase.set('answer');
      state.timeRemaining.set(1.2);
      expect(timerDisplayText.get()).toBe('Answer: 1.2s');
    });
  });
});

-------------------------------------------------------------------------------
FILE: src/__tests__/utils.test.ts
-------------------------------------------------------------------------------
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { 
  getDifficultyRange, 
  getDifficultyName, 
  randomInRange, 
  generateProblem,
  generateSeed,
  loadSettings,
  saveSettings,
  loadTheme,
  saveTheme,
  debounce
} from '../utils';

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => { store[key] = value; },
    removeItem: (key: string) => { delete store[key]; },
    clear: () => { store = {}; }
  };
})();

Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
});

describe('getDifficultyRange', () => {
  it('should return correct ranges for each difficulty level', () => {
    expect(getDifficultyRange(1)).toEqual({ min: 2, max: 5 });
    expect(getDifficultyRange(2)).toEqual({ min: 4, max: 8 });
    expect(getDifficultyRange(3)).toEqual({ min: 6, max: 12 });
    expect(getDifficultyRange(4)).toEqual({ min: 10, max: 20 });
  });
});

describe('getDifficultyName', () => {
  it('should return correct names for each difficulty level', () => {
    expect(getDifficultyName(1)).toBe('Easy');
    expect(getDifficultyName(2)).toBe('Medium');
    expect(getDifficultyName(3)).toBe('Hard');
    expect(getDifficultyName(4)).toBe('Expert');
  });
});

describe('randomInRange', () => {
  it('should generate numbers within specified range', () => {
    for (let i = 0; i < 100; i++) {
      const num = randomInRange(5, 10);
      expect(num).toBeGreaterThanOrEqual(5);
      expect(num).toBeLessThanOrEqual(10);
    }
  });

  it('should handle single value range', () => {
    const num = randomInRange(5, 5);
    expect(num).toBe(5);
  });
});

describe('generateProblem', () => {
  it('should generate problems within difficulty range', () => {
    // Test Easy difficulty
    for (let i = 0; i < 20; i++) {
      const problem = generateProblem(1);
      expect(problem.a).toBeGreaterThanOrEqual(2);
      expect(problem.a).toBeLessThanOrEqual(5);
      expect(problem.b).toBeGreaterThanOrEqual(2);
      expect(problem.b).toBeLessThanOrEqual(5);
    }

    // Test Expert difficulty
    for (let i = 0; i < 20; i++) {
      const problem = generateProblem(4);
      expect(problem.a).toBeGreaterThanOrEqual(10);
      expect(problem.a).toBeLessThanOrEqual(20);
      expect(problem.b).toBeGreaterThanOrEqual(10);
      expect(problem.b).toBeLessThanOrEqual(20);
    }
  });
});

describe('generateSeed', () => {
  it('should generate seed within difficulty range', () => {
    // Test Easy difficulty
    for (let i = 0; i < 20; i++) {
      const seed = generateSeed(1);
      expect(seed).toBeGreaterThanOrEqual(2);
      expect(seed).toBeLessThanOrEqual(5);
    }

    // Test Expert difficulty
    for (let i = 0; i < 20; i++) {
      const seed = generateSeed(4);
      expect(seed).toBeGreaterThanOrEqual(10);
      expect(seed).toBeLessThanOrEqual(20);
    }
  });
});

describe('Settings persistence', () => {
  beforeEach(() => {
    localStorageMock.clear();
  });

  it('should save and load settings', () => {
    const settings = {
      questionTime: 10,
      answerTime: 5,
      difficulty: 2 as const,
      autoUpdate: true
    };

    saveSettings(settings);
    const loaded = loadSettings();
    expect(loaded).toEqual(settings);
  });

  it('should return null for missing settings', () => {
    expect(loadSettings()).toBeNull();
  });

  it('should handle corrupted localStorage data', () => {
    localStorageMock.setItem('mathQuizSettings', 'invalid json');
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    expect(loadSettings()).toBeNull();
    expect(consoleSpy).toHaveBeenCalled();
    
    consoleSpy.mockRestore();
  });
});

describe('Theme persistence', () => {
  beforeEach(() => {
    localStorageMock.clear();
  });

  it('should save and load theme', () => {
    saveTheme('light');
    expect(loadTheme()).toBe('light');
    
    saveTheme('dark');
    expect(loadTheme()).toBe('dark');
  });

  it('should default to dark theme', () => {
    expect(loadTheme()).toBe('dark');
  });
});

describe('debounce', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should debounce function calls', () => {
    const fn = vi.fn();
    const debounced = debounce(fn, 100);

    // Call multiple times rapidly
    debounced();
    debounced();
    debounced();

    // Function shouldn't be called yet
    expect(fn).not.toHaveBeenCalled();

    // Fast forward time
    vi.advanceTimersByTime(100);

    // Function should be called once
    expect(fn).toHaveBeenCalledTimes(1);
  });

  it('should pass arguments to debounced function', () => {
    const fn = vi.fn();
    const debounced = debounce(fn, 100);

    debounced('arg1', 'arg2');
    vi.advanceTimersByTime(100);

    expect(fn).toHaveBeenCalledWith('arg1', 'arg2');
  });

  it('should cancel previous timeout on new call', () => {
    const fn = vi.fn();
    const debounced = debounce(fn, 100);

    debounced();
    vi.advanceTimersByTime(50);
    debounced(); // This should cancel the first timeout
    vi.advanceTimersByTime(50);
    
    // Function still shouldn't be called
    expect(fn).not.toHaveBeenCalled();

    vi.advanceTimersByTime(50);
    
    // Now it should be called once
    expect(fn).toHaveBeenCalledTimes(1);
  });
});

-------------------------------------------------------------------------------
FILE: src/app.ts
-------------------------------------------------------------------------------
import { effect } from './signals';
import { state, displayText, progressPercent, timerDisplayText } from './state';
import { DifficultyLevel, Settings } from './types';
import { 
  generateProblem, 
  getDifficultyName, 
  loadSettings, 
  saveSettings,
  loadTheme,
  saveTheme,
  generateSeed,
  debounce
} from './utils';

// DOM Elements
interface DOMElements {
  display: HTMLElement;
  progressBar: HTMLElement;
  timerDisplay: HTMLElement;
  questionTimeValue: HTMLElement;
  answerTimeValue: HTMLElement;
  difficultyValue: HTMLElement;
  quizButton: HTMLButtonElement;
  modeStatus: HTMLElement;
  quizStatus: HTMLElement;
  updateTime: HTMLElement;
  questionTimeSlider: HTMLInputElement;
  answerTimeSlider: HTMLInputElement;
  difficultySlider: HTMLInputElement;
  incrementBtn: HTMLButtonElement;
  resetBtn: HTMLButtonElement;
  autoUpdateCheckbox: HTMLInputElement;
}

let elements: DOMElements;
let animationFrameId: number | null = null;
let lastTimestamp = 0;
let autoUpdateTimer: ReturnType<typeof setInterval> | null = null;

function getElements(): DOMElements {
  return {
    display: document.getElementById('display')!,
    progressBar: document.getElementById('progressBar')!,
    timerDisplay: document.getElementById('timerDisplay')!,
    questionTimeValue: document.getElementById('questionTimeValue')!,
    answerTimeValue: document.getElementById('answerTimeValue')!,
    difficultyValue: document.getElementById('difficultyValue')!,
    quizButton: document.getElementById('quizButton')! as HTMLButtonElement,
    modeStatus: document.getElementById('modeStatus')!,
    quizStatus: document.getElementById('quizStatus')!,
    updateTime: document.getElementById('updateTime')!,
    questionTimeSlider: document.getElementById('questionTime')! as HTMLInputElement,
    answerTimeSlider: document.getElementById('answerTime')! as HTMLInputElement,
    difficultySlider: document.getElementById('difficulty')! as HTMLInputElement,
    incrementBtn: document.getElementById('incrementBtn')! as HTMLButtonElement,
    resetBtn: document.getElementById('resetBtn')! as HTMLButtonElement,
    autoUpdateCheckbox: document.getElementById('autoUpdate')! as HTMLInputElement
  };
}

function gameLoop(timestamp: number): void {
  if (!state.isQuizActive.get()) {
    animationFrameId = null;
    return;
  }

  if (!lastTimestamp) {
    lastTimestamp = timestamp;
  }

  const deltaTime = (timestamp - lastTimestamp) / 1000; // Time elapsed in seconds
  lastTimestamp = timestamp;

  const newTime = Math.max(0, state.timeRemaining.get() - deltaTime);
  state.timeRemaining.set(newTime);
  updateLastTime();

  if (newTime === 0) {
    const currentPhase = state.currentPhase.get();
    if (currentPhase === 'question') {
      state.currentPhase.set('answer');
      state.timeRemaining.set(state.answerTime.get());
    } else if (currentPhase === 'answer') {
      startNextProblem();
    }
  }

  animationFrameId = requestAnimationFrame(gameLoop);
}

function startNextProblem(): void {
  state.currentProblem.set(generateProblem(state.difficulty.get()));
  state.currentPhase.set('question');
  state.timeRemaining.set(state.questionTime.get());
}

export function toggleQuiz(): void {
  const willBeActive = !state.isQuizActive.get();
  state.isQuizActive.set(willBeActive);

  if (willBeActive) {
    lastTimestamp = 0; // Reset timestamp for the first frame
    startNextProblem();
    if (!animationFrameId) {
      animationFrameId = requestAnimationFrame(gameLoop);
    }
  } else {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    state.currentPhase.set('idle');
    state.timeRemaining.set(0);
    updateLastTime();
  }
}

export function increment(): void {
  state.counter.set(state.counter.get() + 1);
  updateLastTime();
}

export function reset(): void {
  state.counter.set(0);
  state.seed.set(generateSeed(state.difficulty.get()));
  updateLastTime();
}

function updateLastTime(): void {
  elements.updateTime.textContent = new Date().toLocaleTimeString();
}

export function toggleAutoUpdate(checked: boolean): void {
  state.autoUpdateEnabled.set(checked);
}

function startAutoUpdate(): void {
  if (autoUpdateTimer) return;
  autoUpdateTimer = setInterval(() => {
    if (!state.isQuizActive.get() && state.autoUpdateEnabled.get()) {
      increment();
    }
  }, 3000);
}

function stopAutoUpdate(): void {
  if (autoUpdateTimer) {
    clearInterval(autoUpdateTimer);
    autoUpdateTimer = null;
  }
}

export function toggleTheme(): void {
  document.body.classList.toggle('light-mode');
  saveTheme(document.body.classList.contains('light-mode') ? 'light' : 'dark');
}

function initializeSettings(): void {
  const saved = loadSettings();
  if (saved) {
    // Load and apply settings with proper fallbacks to defaults
    const questionTime = saved.questionTime ?? 5;
    const answerTime = saved.answerTime ?? 3;
    const difficulty = saved.difficulty ?? 3;
    const autoUpdate = saved.autoUpdate ?? false;
    
    state.questionTime.set(questionTime);
    state.answerTime.set(answerTime);
    state.difficulty.set(difficulty);
    state.autoUpdateEnabled.set(autoUpdate);
    // Set seed based on loaded difficulty
    state.seed.set(generateSeed(difficulty));
    
    // Sync the DOM elements with loaded values
    elements.questionTimeSlider.value = questionTime.toString();
    elements.answerTimeSlider.value = answerTime.toString();
    elements.difficultySlider.value = difficulty.toString();
    elements.autoUpdateCheckbox.checked = autoUpdate;
  } else {
    // No saved settings, ensure DOM matches default state values
    elements.questionTimeSlider.value = state.questionTime.get().toString();
    elements.answerTimeSlider.value = state.answerTime.get().toString();
    elements.difficultySlider.value = state.difficulty.get().toString();
    elements.autoUpdateCheckbox.checked = state.autoUpdateEnabled.get();
  }
  
  // Load theme preference
  if (loadTheme() === 'light') {
    document.body.classList.add('light-mode');
  }
}

function setupEffects(): void {
  // DOM updates
  effect(() => { elements.display.textContent = displayText.get(); });
  effect(() => { elements.timerDisplay.textContent = timerDisplayText.get(); });
  
  effect(() => {
    const percent = progressPercent.get();
    elements.progressBar.style.width = `${percent}%`;
    
    const phase = state.currentPhase.get();
    const color = phase === 'question' 
      ? 'linear-gradient(90deg, var(--success), #34d399)'
      : 'linear-gradient(90deg, var(--warning), #fbbf24)';
    elements.progressBar.style.background = color;
  });

  effect(() => {
    const isActive = state.isQuizActive.get();
    elements.quizButton.textContent = isActive ? 'Stop Quiz' : 'Start Quiz';
    elements.modeStatus.textContent = isActive ? 'Quiz' : 'Manual';
    elements.quizStatus.textContent = isActive ? 'Running' : 'Stopped';
    
    const disabled = isActive;
    elements.questionTimeSlider.disabled = disabled;
    elements.answerTimeSlider.disabled = disabled;
    elements.difficultySlider.disabled = disabled;
    elements.incrementBtn.disabled = disabled;
    elements.resetBtn.disabled = disabled;
    elements.autoUpdateCheckbox.disabled = disabled;
  });

  effect(() => {
    const autoUpdate = state.autoUpdateEnabled.get();
    const quizActive = state.isQuizActive.get();
    
    if (autoUpdate && !quizActive) {
      startAutoUpdate();
    } else {
      stopAutoUpdate();
    }
  });

  // Create a debounced save function
  const debouncedSave = debounce(saveSettingsToStorage, 300);

  // Settings persistence with debounce
  effect(() => { 
    const time = state.questionTime.get();
    elements.questionTimeValue.textContent = `${time}s`;
    elements.questionTimeSlider.setAttribute('aria-valuenow', time.toString());
    elements.questionTimeSlider.setAttribute('aria-valuetext', `${time} seconds`);
    debouncedSave();
  });
  
  effect(() => { 
    const time = state.answerTime.get();
    elements.answerTimeValue.textContent = `${time}s`;
    elements.answerTimeSlider.setAttribute('aria-valuenow', time.toString());
    elements.answerTimeSlider.setAttribute('aria-valuetext', `${time} seconds`);
    debouncedSave();
  });
  
  effect(() => { 
    const difficulty = state.difficulty.get();
    const name = getDifficultyName(difficulty);
    elements.difficultyValue.textContent = name;
    elements.difficultySlider.setAttribute('aria-valuenow', difficulty.toString());
    elements.difficultySlider.setAttribute('aria-valuetext', name);
    // Update seed when difficulty changes in manual mode
    if (!state.isQuizActive.get()) {
      state.seed.set(generateSeed(difficulty));
    }
    debouncedSave();
  });
  
  effect(() => { 
    debouncedSave(); // For autoUpdate changes
  });
}

function saveSettingsToStorage(): void {
  const settings: Settings = {
    questionTime: state.questionTime.get(),
    answerTime: state.answerTime.get(),
    difficulty: state.difficulty.get(),
    autoUpdate: state.autoUpdateEnabled.get()
  };
  saveSettings(settings);
}

function setupEventListeners(): void {
  elements.questionTimeSlider.addEventListener('input', (e) => {
    const value = parseInt((e.target as HTMLInputElement).value);
    state.questionTime.set(Math.max(1, value));
  });
  
  elements.answerTimeSlider.addEventListener('input', (e) => {
    const value = parseInt((e.target as HTMLInputElement).value);
    state.answerTime.set(Math.max(1, value));
  });
  
  elements.difficultySlider.addEventListener('input', (e) => {
    const value = parseInt((e.target as HTMLInputElement).value) as DifficultyLevel;
    state.difficulty.set(value);
  });
  
  // Handle visibility change for auto-update
  document.addEventListener('visibilitychange', () => {
    if (!state.isQuizActive.get() && state.autoUpdateEnabled.get()) {
      if (document.hidden) {
        stopAutoUpdate();
      } else {
        startAutoUpdate();
      }
    }
  });
}

export function initialize(): void {
  elements = getElements();
  initializeSettings();
  setupEffects();
  setupEventListeners();
  updateLastTime();
}

// Export for testing
export { state, elements };

-------------------------------------------------------------------------------
FILE: src/main.ts
-------------------------------------------------------------------------------
import './style.css';
import { initialize, toggleQuiz, increment, reset, toggleAutoUpdate, toggleTheme } from './app';

// Make functions globally available for onclick handlers
declare global {
  interface Window {
    toggleQuiz: typeof toggleQuiz;
    increment: typeof increment;
    reset: typeof reset;
    toggleAutoUpdate: typeof toggleAutoUpdate;
    toggleTheme: typeof toggleTheme;
  }
}

window.toggleQuiz = toggleQuiz;
window.increment = increment;
window.reset = reset;
window.toggleAutoUpdate = toggleAutoUpdate;
window.toggleTheme = toggleTheme;

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', initialize);

-------------------------------------------------------------------------------
FILE: src/signals.ts
-------------------------------------------------------------------------------
// Robust Signal System with TypeScript
export type EffectFn = () => void;

let currentEffect: EffectFn | null = null;

export class Signal<T> {
  private _value: T;
  private observers = new Set<EffectFn>();

  constructor(initialValue: T) {
    this._value = initialValue;
  }

  get(): T {
    if (currentEffect) {
      this.observers.add(currentEffect);
    }
    return this._value;
  }

  set(newValue: T): void {
    if (this._value === newValue) return;
    this._value = newValue;
    // Create a copy to prevent issues if observers modify the set during iteration
    [...this.observers].forEach(observer => observer());
  }

  // For testing purposes
  getObserverCount(): number {
    return this.observers.size;
  }
}

export class ComputedSignal<T> {
  private computeFn: () => T;
  private observers = new Set<EffectFn>();
  private _value: T | undefined = undefined;
  private isStale = true;
  private markStaleEffect: EffectFn;

  constructor(computeFn: () => T) {
    this.computeFn = computeFn;
    
    // This effect runs when a dependency changes, marking this computed signal as stale
    this.markStaleEffect = () => {
      if (!this.isStale) {
        this.isStale = true;
        [...this.observers].forEach(observer => observer());
      }
    };
  }

  private _compute(): void {
    // Set this computed signal's effect as the current one to register dependencies
    const prevEffect = currentEffect;
    currentEffect = this.markStaleEffect;
    try {
      this._value = this.computeFn();
      this.isStale = false;
    } finally {
      // Restore the previous effect
      currentEffect = prevEffect;
    }
  }

  get(): T {
    // Register the outer effect as an observer of this computed signal
    if (currentEffect) {
      this.observers.add(currentEffect);
    }
    // Re-compute the value only if it's stale
    if (this.isStale) {
      this._compute();
    }
    return this._value as T;
  }
}

export function effect(effectFn: EffectFn): void {
  const execute = () => {
    // Manage a stack of effects to allow for nesting
    const prevEffect = currentEffect;
    currentEffect = execute;
    try {
      effectFn();
    } finally {
      currentEffect = prevEffect;
    }
  };
  execute();
}

-------------------------------------------------------------------------------
FILE: src/state.ts
-------------------------------------------------------------------------------
import { Signal, ComputedSignal } from './signals';
import { Problem, QuizPhase, DifficultyLevel } from './types';
import { generateSeed } from './utils';

// Application State
export const state = {
  counter: new Signal(0),
  seed: new Signal(generateSeed(3)), // Initialize with default difficulty
  questionTime: new Signal(5),
  answerTime: new Signal(3),
  difficulty: new Signal<DifficultyLevel>(3),
  isQuizActive: new Signal(false),
  currentPhase: new Signal<QuizPhase>('idle'),
  timeRemaining: new Signal(0),
  autoUpdateEnabled: new Signal(false),
  currentProblem: new Signal<Problem>({ a: 0, b: 0 })
};

// Computed Values (Derived State)
export const displayText = new ComputedSignal(() => {
  if (state.isQuizActive.get()) {
    const phase = state.currentPhase.get();
    const p = state.currentProblem.get();
    if (phase === 'question') {
      return `${p.a} Ã— ${p.b}`;
    } else if (phase === 'answer') {
      return `${p.a} Ã— ${p.b} = ${p.a * p.b}`;
    }
  }
  // Manual mode display
  const count = state.counter.get();
  const seed = state.seed.get();
  return `${count} Ã— ${seed} = ${count * seed}`;
});

export const progressPercent = new ComputedSignal(() => {
  if (!state.isQuizActive.get()) return 0;
  
  const phase = state.currentPhase.get();
  const totalTime = phase === 'question' 
    ? state.questionTime.get() 
    : state.answerTime.get();
  const remaining = state.timeRemaining.get();
  
  if (totalTime === 0) return 0;
  return ((totalTime - remaining) / totalTime) * 100;
});

export const timerDisplayText = new ComputedSignal(() => {
  if (!state.isQuizActive.get()) return 'Ready';
  
  const phase = state.currentPhase.get();
  const remaining = state.timeRemaining.get();
  const phaseText = phase.charAt(0).toUpperCase() + phase.slice(1);
  return `${phaseText}: ${remaining.toFixed(1)}s`;
});

-------------------------------------------------------------------------------
FILE: src/style.css
-------------------------------------------------------------------------------
:root {
    --bg-primary: #0a0a0a;
    --bg-secondary: #1a1a1a;
    --bg-tertiary: #2a2a2a;
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --accent-primary: #4f46e5;
    --accent-secondary: #7c3aed;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --border: #333333;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    transition: all 0.3s ease;
}

body.light-mode {
    --bg-primary: #ffffff;
    --bg-secondary: #f3f4f6;
    --bg-tertiary: #e5e7eb;
    --text-primary: #111827;
    --text-secondary: #6b7280;
    --border: #d1d5db;
    background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0, #ff0080);
    background-size: 400% 400%;
    animation: rainbow 15s ease infinite;
}

@keyframes rainbow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.container {
    background: var(--bg-secondary);
    border-radius: 20px;
    padding: 40px;
    max-width: 600px;
    width: 100%;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    border: 1px solid var(--border);
}

h1 {
    text-align: center;
    margin-bottom: 30px;
    font-size: 2.5em;
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.section {
    background: var(--bg-tertiary);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid var(--border);
    transition: all 0.3s ease;
}

.section:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.quiz-display {
    text-align: center;
    font-size: 3em;
    font-weight: bold;
    margin: 30px 0;
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-primary);
    border-radius: 12px;
    padding: 20px;
    border: 2px solid var(--border);
    position: relative;
    overflow: hidden;
}

.quiz-display::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(79, 70, 229, 0.1), transparent);
    transform: rotate(45deg);
    animation: shine 3s infinite;
}

@keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
}

.progress-container {
    width: 100%;
    height: 30px;
    background: var(--bg-primary);
    border-radius: 15px;
    overflow: hidden;
    margin-bottom: 20px;
    position: relative;
    border: 1px solid var(--border);
}

.progress-bar {
    height: 100%;
    width: 0%;
    border-radius: 15px;
    transition: width 0.1s linear, background 0.5s ease;
    background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
    position: relative;
    overflow: hidden;
}

.progress-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.timer-display {
    text-align: center;
    font-size: 1.5em;
    margin-bottom: 20px;
    font-weight: 600;
    color: var(--accent-primary);
}

.controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.slider-group {
    display: flex;
    align-items: center;
    gap: 15px;
}

.slider-group label {
    flex: 1;
    font-weight: 500;
    color: var(--text-secondary);
}

.slider-group input[type="range"] {
    flex: 2;
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    background: var(--bg-primary);
    border-radius: 4px;
    outline: none;
    cursor: pointer;
}

.slider-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--accent-primary);
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
}

.slider-group input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    background: var(--accent-secondary);
}

.slider-group input[type="range"]:focus {
    outline: 2px solid var(--accent-primary);
    outline-offset: 2px;
}

.slider-group input[type="range"]:focus::-webkit-slider-thumb {
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.3);
}

.slider-value {
    min-width: 50px;
    text-align: center;
    font-weight: bold;
    color: var(--accent-primary);
    font-size: 1.1em;
}

button {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:hover::before {
    width: 300px;
    height: 300px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(79, 70, 229, 0.3);
}

button:active {
    transform: translateY(0);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: translateY(0);
    box-shadow: none;
}

button:disabled:hover::before {
    width: 0;
    height: 0;
}

.button-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.button-group button {
    flex: 1;
    min-width: 120px;
}

.toggle {
    display: flex;
    align-items: center;
    gap: 10px;
}

.toggle input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.status {
    background: var(--bg-primary);
    border-radius: 8px;
    padding: 15px;
    margin-top: 20px;
    border: 1px solid var(--border);
}

.status-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    color: var(--text-secondary);
}

.status-item:last-child {
    margin-bottom: 0;
}

.status-value {
    color: var(--text-primary);
    font-weight: 600;
}

.theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}

.theme-toggle:hover {
    background: var(--accent-primary);
    color: white;
}

@media (max-width: 600px) {
    .container {
        padding: 20px;
    }
    
    .quiz-display {
        font-size: 2.2em;
    }
    
    h1 {
        font-size: 2em;
    }
}

-------------------------------------------------------------------------------
FILE: src/types.ts
-------------------------------------------------------------------------------
export interface Problem {
  a: number;
  b: number;
}

export type QuizPhase = 'idle' | 'question' | 'answer';

export type DifficultyLevel = 1 | 2 | 3 | 4;

export interface DifficultyRange {
  min: number;
  max: number;
}

export interface Settings {
  questionTime: number;
  answerTime: number;
  difficulty: DifficultyLevel;
  autoUpdate: boolean;
}

export interface AppState {
  counter: number;
  seed: number;
  questionTime: number;
  answerTime: number;
  difficulty: DifficultyLevel;
  isQuizActive: boolean;
  currentPhase: QuizPhase;
  timeRemaining: number;
  autoUpdateEnabled: boolean;
  currentProblem: Problem;
}

-------------------------------------------------------------------------------
FILE: src/utils.ts
-------------------------------------------------------------------------------
import { DifficultyLevel, DifficultyRange, Problem, Settings } from './types';

export function getDifficultyRange(level: DifficultyLevel): DifficultyRange {
  switch(level) {
    case 1: return { min: 2, max: 5 };   // Easy: 2-5
    case 2: return { min: 4, max: 8 };   // Medium: 4-8  
    case 3: return { min: 6, max: 12 };  // Hard: 6-12
    case 4: return { min: 10, max: 20 }; // Expert: 10-20
    default: return { min: 6, max: 12 };
  }
}

export function getDifficultyName(level: DifficultyLevel): string {
  switch(level) {
    case 1: return 'Easy';
    case 2: return 'Medium';
    case 3: return 'Hard';
    case 4: return 'Expert';
    default: return 'Hard';
  }
}

export function randomInRange(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

export function generateProblem(difficulty: DifficultyLevel): Problem {
  const range = getDifficultyRange(difficulty);
  
  return {
    a: randomInRange(range.min, range.max),
    b: randomInRange(range.min, range.max)
  };
}

export function generateSeed(difficulty: DifficultyLevel): number {
  const range = getDifficultyRange(difficulty);
  return randomInRange(range.min, range.max);
}

export function loadSettings(): Settings | null {
  try {
    const saved = localStorage.getItem('mathQuizSettings');
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Failed to load settings - resetting to defaults', e);
    try {
      localStorage.removeItem('mathQuizSettings');
    } catch {
      // Ignore if we can't remove
    }
  }
  return null;
}

export function saveSettings(settings: Settings): void {
  try {
    localStorage.setItem('mathQuizSettings', JSON.stringify(settings));
  } catch (e) {
    // Silently fail if localStorage is disabled (e.g., private mode)
    console.warn('Failed to save settings:', e);
  }
}

export function loadTheme(): 'light' | 'dark' {
  try {
    return localStorage.getItem('theme') === 'light' ? 'light' : 'dark';
  } catch {
    return 'dark';
  }
}

export function saveTheme(theme: 'light' | 'dark'): void {
  try {
    localStorage.setItem('theme', theme);
  } catch {
    // Silently fail if localStorage is disabled
  }
}

// Debounce utility
export function debounce<T extends (...args: unknown[]) => void>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

-------------------------------------------------------------------------------
FILE: tsconfig.e2e.json
-------------------------------------------------------------------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node"]
  },
  "include": ["e2e/**/*.ts"]
}


-------------------------------------------------------------------------------
FILE: tsconfig.json
-------------------------------------------------------------------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"]
}

-------------------------------------------------------------------------------
FILE: vite.config.ts
-------------------------------------------------------------------------------
import { defineConfig } from 'vite';

export default defineConfig({
  base: './', // Use relative paths for GitHub Pages
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      input: {
        main: './index.html',
      },
    },
  },
});

-------------------------------------------------------------------------------
FILE: vitest.config.ts
-------------------------------------------------------------------------------
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    include: ['src/**/*.test.ts', 'src/**/*.spec.ts'],
    exclude: [
      'node_modules/**',
      'dist/**',
      'coverage/**',
      'e2e/**',
      '**/*.d.ts',
    ],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      exclude: [
        'node_modules/**',
        'dist/**',
        'coverage/**',
        '**/*.d.ts',
        '**/*.config.*',
        '**/*.cjs',
        'scripts/**',
        'src/__tests__/**',
        'src/main.ts', // Entry point is mostly DOM manipulation
        'src/app.ts', // Mostly DOM manipulation, hard to test without full integration tests
        'e2e/**',
      ],
      include: [
        'src/**/*.ts'
      ],
      all: true, // Include all matching source files in coverage
    }
  }
});

===============================================================================
EXPORT COMPLETE â€” 23 files
===============================================================================
